from heapq import heappop, heappushfrom math import sqrtdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}    print(f'Going from {source_point} to {destination_point}')    key_boxes = find_boxes(source_point, destination_point, mesh)    print(f'key boxes is {key_boxes}')    if key_boxes['end'] is None:        return None    start_box = key_boxes['start']    end_box = key_boxes['end']    h = []    heappush(h, (0, start_box, source_point, destination_point))    heappush(h, (0, end_box, destination_point, source_point))    came_from = dict()    came_from[start_box] = None    cost_so_far = dict()    cost_so_far[start_box] = 0    came_from_backwords = dict()    cost_so_far_backwords = dict()    cost_so_far_backwords[end_box] = 0    came_from_backwords[end_box] = None    current_point = source_point    points = dict()    break_point = None    while not h == []:        obj = heappop(h)        current = obj[1]        current_point = obj[2]        current_goal = obj[3]        if current_goal == destination_point:            if current in came_from_backwords:                break_point = current                break        if current_goal == source_point:            if current in came_from:                break_point = current                break        for nxt in mesh['adj'][current]:            dist, point = find_least_dist_to_box(current, nxt, current_point)            new_cost = 0            if current_goal == destination_point:                new_cost = cost_so_far[current] + dist            else:                new_cost = cost_so_far_backwords[current] + dist            if current_goal == destination_point:                if nxt not in came_from or new_cost < cost_so_far[nxt]:                    cost_so_far[nxt] = new_cost                    came_from[nxt] = current                    priority = new_cost + distance(point, current_goal)                    heappush(h, (priority, nxt, point, current_goal))                    points[nxt] = point            elif current_goal == source_point:                if nxt not in came_from_backwords or new_cost < cost_so_far_backwords[nxt]:                    cost_so_far_backwords[nxt] = new_cost                    came_from_backwords[nxt] = current                    priority = new_cost + distance(point, current_goal)                    heappush(h, (priority, nxt, point, current_goal))                    points[nxt] = point    print(break_point in came_from and break_point in came_from_backwords)    f_ptr = break_point    b_ptr = break_point    while came_from[f_ptr] is not None:        path.append(points[f_ptr])        boxes[f_ptr] = 1        f_ptr = came_from[f_ptr]    while came_from_backwords[b_ptr] is not None:        path.insert(0, points[b_ptr])        boxes[b_ptr] = 1        b_ptr = came_from_backwords[b_ptr]    boxes[start_box] = 1    boxes[end_box] = 1    path.append(source_point)    path.insert(0, destination_point)    print(f'path of boxes is {boxes}')    return path, boxes.keys()def find_boxes(start, end, mesh):    boxes = {}    for box in mesh['boxes']:        if box[1] >= start[0] >= box[0]:            if box[3] >= start[1] >= box[2]:                print(f'found start box, {start} in {box}')                boxes['start'] = box        if box[1] >= end[0] >= box[0]:            if box[3] >= end[1] >= box[2]:                print(f'found end box, {end} in {box}')                boxes['end'] = box    return boxesdef find_least_dist_to_box(b1, b2, point):    x_range = [max(b1[0], b2[0]), min(b1[1], b2[1])]    y_range = [max(b1[2], b2[2]), min(b1[3], b2[3])]    new_x = 0    new_y = 0    if x_range[0] <= point[0] <= x_range[1]:        new_x = point[0]    else:        if point[0] < x_range[0]:            new_x = x_range[0]        else:            new_x = x_range[1]    if y_range[0] <= point[1] <= y_range[1]:        new_y = point[1]    else:        if point[0] < y_range[0]:            new_y = y_range[0]        else:            new_y = y_range[1]    dist = sqrt(((new_x - point[0]) ** 2) + (new_y - point[1]) ** 2)    return dist, (new_x, new_y)def distance(p1, p2):    return sqrt(((p2[0] - p1[0]) ** 2) + (p2[1] - p1[1]) ** 2)