from heapq import heappop, heappushfrom math import sqrtdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}    print(f'Going from {source_point} to {destination_point}')    key_boxes = find_boxes(source_point, destination_point, mesh)    print(f'key boxes is {key_boxes}')    start_box = key_boxes['start']    end_box = key_boxes['end']    h = []    heappush(h, (0, start_box, source_point))    came_from = dict()    came_from[start_box] = None    cost_so_far = dict()    cost_so_far[start_box] = 0    current_point = source_point    points = dict()    while not h == []:        obj = heappop(h)        current = obj[1]        current_point = obj[2]        if current == end_box:            break        for nxt in mesh['adj'][current]:            dist, point = find_least_dist_to_box(current, nxt, current_point)            new_cost = cost_so_far[current] + dist            if nxt not in came_from or new_cost < cost_so_far[nxt]:                cost_so_far[nxt] = new_cost                priority = new_cost + distance(point, destination_point)                heappush(h, (priority, nxt, point))                came_from[nxt] = current                points[nxt] = point    ptr = end_box    path.append(destination_point)    while ptr is not start_box:        boxes[ptr] = 1        path.append(points[ptr])        ptr = came_from[ptr]    boxes[ptr] = 1    path.append(source_point)    print(f'path of boxes is {boxes}')    return path, boxes.keys()def find_boxes(start, end, mesh):    boxes = {}    for box in mesh['boxes']:        if box[1] >= start[0] >= box[0]:            if box[3] >= start[1] >= box[2]:                print(f'found start box, {start} in {box}')                boxes['start'] = box        if box[1] >= end[0] >= box[0]:            if box[3] >= end[1] >= box[2]:                print(f'found end box, {end} in {box}')                boxes['end'] = box    return boxesdef find_least_dist_to_box(b1, b2, point):    x_range = [max(b1[0], b2[0]), min(b1[1], b2[1])]    y_range = [max(b1[2], b2[2]), min(b1[3], b2[3])]    new_x = 0    new_y = 0    if x_range[0] <= point[0] <= x_range[1]:        new_x = point[0]    else:        if point[0] < x_range[0]:            new_x = x_range[0]        else:            new_x = x_range[1]    if y_range[0] <= point[1] <= y_range[1]:        new_y = point[1]    else:        if point[0] < y_range[0]:            new_y = y_range[0]        else:            new_y = y_range[1]    dist = sqrt(((new_x - point[0]) ** 2) + (new_y - point[1]) ** 2)    return dist, (new_x, new_y)def distance(p1, p2):    return sqrt(((p2[0] - p1[0]) ** 2) + (p2[1] - p1[1]) ** 2)